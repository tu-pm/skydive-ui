/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Skydive API
 * The Skydive REST API allows to communicate with a Skydive analyzer.
 *
 * OpenAPI spec version: 0.25.0
 * Contact: skydive-dev@redhat.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

// INFO(safchain) workaround, see: https://github.com/swagger-api/swagger-codegen/issues/6403
import { stringify as qs_stringify } from "querystring";
class URLSearchParams {
    data: any;

    constructor() {
        this.data = {};
    }

    set(k, v) {
        this.data[k] = v;
    }

    toString() {
        return qs_stringify(this.data);
    }
}

// url.URLSearchParams = URLSearchParams;

const BASE_PATH = "http://localhost:8082/api".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * Status describes the status of an agent
 * @export
 * @interface AgentStatus
 */
export interface AgentStatus {
    /**
     * 
     * @type {{ [key: string]: ConnStatus; }}
     * @memberof AgentStatus
     */
    Analyzers?: { [key: string]: ConnStatus; };
    /**
     * 
     * @type {{ [key: string]: ConnStatus; }}
     * @memberof AgentStatus
     */
    Clients?: { [key: string]: ConnStatus; };
    /**
     * 
     * @type {Array<string>}
     * @memberof AgentStatus
     */
    FlowProbes?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AgentStatus
     */
    TopologyProbes?: { [key: string]: any; };
}

/**
 * Alerts provide a way to be notified when a Gremlin expression is evaluated to true.  
 * @export
 * @interface Alert
 */
export interface Alert {
    /**
     * Action to execute when the alert is triggered. Can be either an empty string, or a URL (use 'file://' for local scripts)
     * @type {string}
     * @memberof Alert
     */
    Action?: string;
    /**
     * 
     * @type {Date}
     * @memberof Alert
     */
    CreateTime?: Date;
    /**
     * Alert description
     * @type {string}
     * @memberof Alert
     */
    Description?: string;
    /**
     * Gremlin or JavaScript expression evaluated to trigger the alarm
     * @type {string}
     * @memberof Alert
     */
    Expression?: string;
    /**
     * Alert name
     * @type {string}
     * @memberof Alert
     */
    Name?: string;
    /**
     * Event that triggers the alert evaluation
     * @type {string}
     * @memberof Alert
     */
    Trigger?: string;
}

/**
 * Alerts
 * @export
 * @interface Alerts
 */
export interface Alerts {
    [key: string]: Alert;

}

/**
 * Status describes the status of an analyzer
 * @export
 * @interface AnalyzerStatus
 */
export interface AnalyzerStatus {
    /**
     * 
     * @type {{ [key: string]: ConnStatus; }}
     * @memberof AnalyzerStatus
     */
    Agents?: { [key: string]: ConnStatus; };
    /**
     * 
     * @type {ElectionStatus}
     * @memberof AnalyzerStatus
     */
    Alerts?: ElectionStatus;
    /**
     * 
     * @type {ElectionStatus}
     * @memberof AnalyzerStatus
     */
    Captures?: ElectionStatus;
    /**
     * 
     * @type {PeersStatus}
     * @memberof AnalyzerStatus
     */
    Peers?: PeersStatus;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AnalyzerStatus
     */
    Probes?: { [key: string]: any; };
    /**
     * 
     * @type {{ [key: string]: ConnStatus; }}
     * @memberof AnalyzerStatus
     */
    Publishers?: { [key: string]: ConnStatus; };
    /**
     * 
     * @type {{ [key: string]: ConnStatus; }}
     * @memberof AnalyzerStatus
     */
    Subscribers?: { [key: string]: ConnStatus; };
}

/**
 * 
 * @export
 * @interface AnyValue
 */
export interface AnyValue {
}

/**
 * AuthenticateOKBody authenticate o k body
 * @export
 * @interface AuthenticateOKBody
 */
export interface AuthenticateOKBody {
    /**
     * An opaque token used to authenticate a user after a successful login
     * @type {string}
     * @memberof AuthenticateOKBody
     */
    IdentityToken: string;
    /**
     * The status of the authentication
     * @type {string}
     * @memberof AuthenticateOKBody
     */
    Status: string;
}

/**
 * BasicResource is a resource with a unique identifier 
 * @export
 * @interface BasicResource
 */
export interface BasicResource {
}

/**
 * Captures provide a way to capture network traffic on the nodes matching a Gremlin expression.  
 * @export
 * @interface Capture
 */
export interface Capture {
    /**
     * BPF filter
     * @type {string}
     * @memberof Capture
     */
    BPFFilter?: string;
    /**
     * Capture description
     * @type {string}
     * @memberof Capture
     */
    Description?: string;
    /**
     * 
     * @type {ExtraLayers}
     * @memberof Capture
     */
    ExtraLayers?: ExtraLayers;
    /**
     * Add additional TCP metrics to flows
     * @type {boolean}
     * @memberof Capture
     */
    ExtraTCPMetric?: boolean;
    /**
     * Gremlin Query
     * @type {string}
     * @memberof Capture
     */
    GremlinQuery: string;
    /**
     * Packet header size to consider
     * @type {number}
     * @memberof Capture
     */
    HeaderSize?: number;
    /**
     * Defragment IPv4 packets
     * @type {boolean}
     * @memberof Capture
     */
    IPDefrag?: boolean;
    /**
     * First layer used by flow key calculation, L2 or L3
     * @type {string}
     * @memberof Capture
     */
    LayerKeyMode?: string;
    /**
     * Capture name
     * @type {string}
     * @memberof Capture
     */
    Name?: string;
    /**
     * Polling interval for SFlow counters, 0: no counter samples
     * @type {number}
     * @memberof Capture
     */
    PollingInterval?: number;
    /**
     * SFlow port
     * @type {number}
     * @memberof Capture
     */
    Port?: number;
    /**
     * Maximum number of raw packets captured, 0: no packet, -1: unlimited
     * @type {number}
     * @memberof Capture
     */
    RawPacketLimit?: number;
    /**
     * Reassemble TCP packets
     * @type {boolean}
     * @memberof Capture
     */
    ReassembleTCP?: boolean;
    /**
     * Sampling rate for SFlow flows. 0: no flow samples
     * @type {number}
     * @memberof Capture
     */
    SamplingRate?: number;
    /**
     * sFlow/NetFlow target, if empty the agent will be used
     * @type {string}
     * @memberof Capture
     */
    Target?: string;
    /**
     * target type (netflowv5, erspanv1), ignored in case of sFlow/NetFlow capture
     * @type {string}
     * @memberof Capture
     */
    TargetType?: string;
    /**
     * Capture type. Can be afpacket, pcap, ebpf, sflow, pcapsocket, ovsmirror, dpdk, ovssflow or ovsnetflow
     * @type {string}
     * @memberof Capture
     */
    Type?: string;
}

/**
 * Captures
 * @export
 * @interface Captures
 */
export interface Captures {
    [key: string]: Capture;

}

/**
 * 
 * @export
 * @interface ConnState
 */
export interface ConnState {
}

/**
 * ConnStatus represents the status of a connection to a hub
 * @export
 * @interface ConnStatus
 */
export interface ConnStatus {
    /**
     * 
     * @type {string}
     * @memberof ConnStatus
     */
    Addr?: string;
    /**
     * 
     * @type {Protocol}
     * @memberof ConnStatus
     */
    ClientProtocol?: Protocol;
    /**
     * 
     * @type {Date}
     * @memberof ConnStatus
     */
    ConnectTime?: Date;
    /**
     * 
     * @type {ConnState}
     * @memberof ConnStatus
     */
    IsConnected?: ConnState;
    /**
     * 
     * @type {boolean}
     * @memberof ConnStatus
     */
    IsMaster?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ConnStatus
     */
    Port?: number;
    /**
     * 
     * @type {string}
     * @memberof ConnStatus
     */
    RemoteHost?: string;
    /**
     * 
     * @type {ServiceType}
     * @memberof ConnStatus
     */
    RemoteServiceType?: ServiceType;
    /**
     * 
     * @type {ServiceType}
     * @memberof ConnStatus
     */
    ServiceType?: ServiceType;
}

/**
 * ContainerCreateCreatedBody container create created body
 * @export
 * @interface ContainerCreateCreatedBody
 */
export interface ContainerCreateCreatedBody {
    /**
     * The ID of the created container
     * @type {string}
     * @memberof ContainerCreateCreatedBody
     */
    Id: string;
    /**
     * Warnings encountered when creating the container
     * @type {Array<string>}
     * @memberof ContainerCreateCreatedBody
     */
    Warnings: Array<string>;
}

/**
 * ContainerUpdateOKBody container update o k body
 * @export
 * @interface ContainerUpdateOKBody
 */
export interface ContainerUpdateOKBody {
    /**
     * warnings
     * @type {Array<string>}
     * @memberof ContainerUpdateOKBody
     */
    Warnings: Array<string>;
}

/**
 * ContainerWaitOKBody container wait o k body
 * @export
 * @interface ContainerWaitOKBody
 */
export interface ContainerWaitOKBody {
    /**
     * Exit code of the container
     * @type {number}
     * @memberof ContainerWaitOKBody
     */
    StatusCode: number;
}

/**
 * Edge rules allow the dynamic creation of links between nodes of the graph.  
 * @export
 * @interface EdgeRule
 */
export interface EdgeRule {
    /**
     * Edge rule description
     * @type {string}
     * @memberof EdgeRule
     */
    Description?: string;
    /**
     * Gremlin expression of the edges destination nodes
     * @type {string}
     * @memberof EdgeRule
     */
    Dst?: string;
    /**
     * 
     * @type {Metadata}
     * @memberof EdgeRule
     */
    Metadata?: Metadata;
    /**
     * Edge rule name
     * @type {string}
     * @memberof EdgeRule
     */
    Name?: string;
    /**
     * Gremlin expression of the edges source nodes
     * @type {string}
     * @memberof EdgeRule
     */
    Src?: string;
}

/**
 * Edge rules
 * @export
 * @interface EdgeRules
 */
export interface EdgeRules {
    [key: string]: EdgeRule;

}

/**
 * ElectionStatus describes the status of an election
 * @export
 * @interface ElectionStatus
 */
export interface ElectionStatus {
    /**
     * 
     * @type {boolean}
     * @memberof ElectionStatus
     */
    IsMaster?: boolean;
}

/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * The error message.
     * @type {string}
     * @memberof ErrorResponse
     */
    message: string;
}

/**
 * ExtraLayers defines extra layer to be pushed in flow
 * @export
 * @interface ExtraLayers
 */
export interface ExtraLayers {
}

/**
 * IDResponse Response to an API call that returns just an Id
 * @export
 * @interface IdResponse
 */
export interface IdResponse {
    /**
     * The id of the newly created object.
     * @type {string}
     * @memberof IdResponse
     */
    Id: string;
}

/**
 * ImageSummary image summary
 * @export
 * @interface ImageSummary
 */
export interface ImageSummary {
    /**
     * containers
     * @type {number}
     * @memberof ImageSummary
     */
    Containers: number;
    /**
     * created
     * @type {number}
     * @memberof ImageSummary
     */
    Created: number;
    /**
     * Id
     * @type {string}
     * @memberof ImageSummary
     */
    Id: string;
    /**
     * labels
     * @type {{ [key: string]: string; }}
     * @memberof ImageSummary
     */
    Labels: { [key: string]: string; };
    /**
     * parent Id
     * @type {string}
     * @memberof ImageSummary
     */
    ParentId: string;
    /**
     * repo digests
     * @type {Array<string>}
     * @memberof ImageSummary
     */
    RepoDigests: Array<string>;
    /**
     * repo tags
     * @type {Array<string>}
     * @memberof ImageSummary
     */
    RepoTags: Array<string>;
    /**
     * shared size
     * @type {number}
     * @memberof ImageSummary
     */
    SharedSize: number;
    /**
     * size
     * @type {number}
     * @memberof ImageSummary
     */
    Size: number;
    /**
     * virtual size
     * @type {number}
     * @memberof ImageSummary
     */
    VirtualSize: number;
}

/**
 * Info for each host describes his API version and service (agent or analyzer)
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * Server host ID
     * @type {string}
     * @memberof Info
     */
    Host?: string;
    /**
     * Service type
     * @type {string}
     * @memberof Info
     */
    Service?: string;
    /**
     * API version
     * @type {string}
     * @memberof Info
     */
    Version?: string;
}

/**
 * Metadata describes the graph node metadata type. It implements ElementMatcher based only on Metadata. 
 * @export
 * @interface Metadata
 */
export interface Metadata {
    [key: string]: any;

}

/**
 * Node rules allow the dynamic creation of nodes in the graph.  
 * @export
 * @interface NodeRule
 */
export interface NodeRule {
    /**
     * 'create' to create nodes, 'update' to updates nodes
     * @type {string}
     * @memberof NodeRule
     */
    Action?: string;
    /**
     * Node rule description
     * @type {string}
     * @memberof NodeRule
     */
    Description?: string;
    /**
     * 
     * @type {Metadata}
     * @memberof NodeRule
     */
    Metadata?: Metadata;
    /**
     * Node rule name
     * @type {string}
     * @memberof NodeRule
     */
    Name?: string;
    /**
     * Gremlin expression of the nodes to update
     * @type {string}
     * @memberof NodeRule
     */
    Query?: string;
}

/**
 * Node rules
 * @export
 * @interface NodeRules
 */
export interface NodeRules {
    [key: string]: NodeRule;

}

/**
 * PacketInjection packet injector API parameters 
 * @export
 * @interface PacketInjection
 */
export interface PacketInjection {
    /**
     * 
     * @type {number}
     * @memberof PacketInjection
     */
    Count?: number;
    /**
     * 
     * @type {string}
     * @memberof PacketInjection
     */
    Dst?: string;
    /**
     * 
     * @type {string}
     * @memberof PacketInjection
     */
    DstIP?: string;
    /**
     * 
     * @type {string}
     * @memberof PacketInjection
     */
    DstMAC?: string;
    /**
     * 
     * @type {number}
     * @memberof PacketInjection
     */
    DstPort?: number;
    /**
     * 
     * @type {number}
     * @memberof PacketInjection
     */
    ICMPID?: number;
    /**
     * 
     * @type {number}
     * @memberof PacketInjection
     */
    IncrementPayload?: number;
    /**
     * 
     * @type {number}
     * @memberof PacketInjection
     */
    Interval?: number;
    /**
     * 
     * @type {string}
     * @memberof PacketInjection
     */
    Mode?: string;
    /**
     * 
     * @type {string}
     * @memberof PacketInjection
     */
    Payload?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PacketInjection
     */
    Pcap?: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof PacketInjection
     */
    Src?: string;
    /**
     * 
     * @type {string}
     * @memberof PacketInjection
     */
    SrcIP?: string;
    /**
     * 
     * @type {string}
     * @memberof PacketInjection
     */
    SrcMAC?: string;
    /**
     * 
     * @type {number}
     * @memberof PacketInjection
     */
    SrcPort?: number;
    /**
     * 
     * @type {Date}
     * @memberof PacketInjection
     */
    StartTime?: Date;
    /**
     * 
     * @type {number}
     * @memberof PacketInjection
     */
    TTL?: number;
    /**
     * 
     * @type {string}
     * @memberof PacketInjection
     */
    Type?: string;
}

/**
 * Injections
 * @export
 * @interface PacketInjections
 */
export interface PacketInjections {
    [key: string]: PacketInjection;

}

/**
 * PeersStatus describes the state of a peer
 * @export
 * @interface PeersStatus
 */
export interface PeersStatus {
    /**
     * 
     * @type {{ [key: string]: ConnStatus; }}
     * @memberof PeersStatus
     */
    Incomers?: { [key: string]: ConnStatus; };
    /**
     * 
     * @type {{ [key: string]: ConnStatus; }}
     * @memberof PeersStatus
     */
    Outgoers?: { [key: string]: ConnStatus; };
}

/**
 * Plugin A plugin for the Engine API
 * @export
 * @interface Plugin
 */
export interface Plugin {
    /**
     * 
     * @type {PluginConfig}
     * @memberof Plugin
     */
    Config: PluginConfig;
    /**
     * True when the plugin is running. False when the plugin is not running, only installed.
     * @type {boolean}
     * @memberof Plugin
     */
    Enabled: boolean;
    /**
     * Id
     * @type {string}
     * @memberof Plugin
     */
    Id?: string;
    /**
     * name
     * @type {string}
     * @memberof Plugin
     */
    Name: string;
    /**
     * plugin remote reference used to push/pull the plugin
     * @type {string}
     * @memberof Plugin
     */
    PluginReference?: string;
    /**
     * 
     * @type {PluginSettings}
     * @memberof Plugin
     */
    Settings: PluginSettings;
}

/**
 * 
 * @export
 * @interface PluginConfig
 */
export interface PluginConfig {
    /**
     * 
     * @type {PluginConfigArgs}
     * @memberof PluginConfig
     */
    Args: PluginConfigArgs;
    /**
     * description
     * @type {string}
     * @memberof PluginConfig
     */
    Description: string;
    /**
     * documentation
     * @type {string}
     * @memberof PluginConfig
     */
    Documentation: string;
    /**
     * entrypoint
     * @type {Array<string>}
     * @memberof PluginConfig
     */
    Entrypoint: Array<string>;
    /**
     * env
     * @type {Array<PluginEnv>}
     * @memberof PluginConfig
     */
    Env: Array<PluginEnv>;
    /**
     * 
     * @type {PluginConfigInterface}
     * @memberof PluginConfig
     */
    _Interface: PluginConfigInterface;
    /**
     * 
     * @type {PluginConfigLinux}
     * @memberof PluginConfig
     */
    Linux: PluginConfigLinux;
    /**
     * mounts
     * @type {Array<PluginMount>}
     * @memberof PluginConfig
     */
    Mounts: Array<PluginMount>;
    /**
     * 
     * @type {PluginConfigNetwork}
     * @memberof PluginConfig
     */
    Network: PluginConfigNetwork;
    /**
     * propagated mount
     * @type {string}
     * @memberof PluginConfig
     */
    PropagatedMount: string;
    /**
     * 
     * @type {PluginConfigUser}
     * @memberof PluginConfig
     */
    User?: PluginConfigUser;
    /**
     * work dir
     * @type {string}
     * @memberof PluginConfig
     */
    WorkDir: string;
    /**
     * 
     * @type {PluginConfigRootfs}
     * @memberof PluginConfig
     */
    rootfs?: PluginConfigRootfs;
}

/**
 * PluginConfigArgs plugin config args
 * @export
 * @interface PluginConfigArgs
 */
export interface PluginConfigArgs {
    /**
     * description
     * @type {string}
     * @memberof PluginConfigArgs
     */
    Description: string;
    /**
     * name
     * @type {string}
     * @memberof PluginConfigArgs
     */
    Name: string;
    /**
     * settable
     * @type {Array<string>}
     * @memberof PluginConfigArgs
     */
    Settable: Array<string>;
    /**
     * value
     * @type {Array<string>}
     * @memberof PluginConfigArgs
     */
    Value: Array<string>;
}

/**
 * PluginConfigInterface The interface between Docker and the plugin
 * @export
 * @interface PluginConfigInterface
 */
export interface PluginConfigInterface {
    /**
     * socket
     * @type {string}
     * @memberof PluginConfigInterface
     */
    Socket: string;
    /**
     * types
     * @type {Array<PluginInterfaceType>}
     * @memberof PluginConfigInterface
     */
    Types: Array<PluginInterfaceType>;
}

/**
 * PluginConfigLinux plugin config linux
 * @export
 * @interface PluginConfigLinux
 */
export interface PluginConfigLinux {
    /**
     * allow all devices
     * @type {boolean}
     * @memberof PluginConfigLinux
     */
    AllowAllDevices: boolean;
    /**
     * capabilities
     * @type {Array<string>}
     * @memberof PluginConfigLinux
     */
    Capabilities: Array<string>;
    /**
     * devices
     * @type {Array<PluginDevice>}
     * @memberof PluginConfigLinux
     */
    Devices: Array<PluginDevice>;
}

/**
 * PluginConfigNetwork plugin config network
 * @export
 * @interface PluginConfigNetwork
 */
export interface PluginConfigNetwork {
    /**
     * type
     * @type {string}
     * @memberof PluginConfigNetwork
     */
    Type: string;
}

/**
 * PluginConfigRootfs plugin config rootfs
 * @export
 * @interface PluginConfigRootfs
 */
export interface PluginConfigRootfs {
    /**
     * diff ids
     * @type {Array<string>}
     * @memberof PluginConfigRootfs
     */
    diff_ids?: Array<string>;
    /**
     * type
     * @type {string}
     * @memberof PluginConfigRootfs
     */
    type?: string;
}

/**
 * PluginConfigUser plugin config user
 * @export
 * @interface PluginConfigUser
 */
export interface PluginConfigUser {
    /**
     * g ID
     * @type {number}
     * @memberof PluginConfigUser
     */
    GID?: number;
    /**
     * UID
     * @type {number}
     * @memberof PluginConfigUser
     */
    UID?: number;
}

/**
 * PluginDevice plugin device
 * @export
 * @interface PluginDevice
 */
export interface PluginDevice {
    /**
     * description
     * @type {string}
     * @memberof PluginDevice
     */
    Description: string;
    /**
     * name
     * @type {string}
     * @memberof PluginDevice
     */
    Name: string;
    /**
     * path
     * @type {string}
     * @memberof PluginDevice
     */
    Path: string;
    /**
     * settable
     * @type {Array<string>}
     * @memberof PluginDevice
     */
    Settable: Array<string>;
}

/**
 * PluginEnv plugin env
 * @export
 * @interface PluginEnv
 */
export interface PluginEnv {
    /**
     * description
     * @type {string}
     * @memberof PluginEnv
     */
    Description: string;
    /**
     * name
     * @type {string}
     * @memberof PluginEnv
     */
    Name: string;
    /**
     * settable
     * @type {Array<string>}
     * @memberof PluginEnv
     */
    Settable: Array<string>;
    /**
     * value
     * @type {string}
     * @memberof PluginEnv
     */
    Value: string;
}

/**
 * PluginInterfaceType plugin interface type
 * @export
 * @interface PluginInterfaceType
 */
export interface PluginInterfaceType {
    /**
     * capability
     * @type {string}
     * @memberof PluginInterfaceType
     */
    Capability: string;
    /**
     * prefix
     * @type {string}
     * @memberof PluginInterfaceType
     */
    Prefix: string;
    /**
     * version
     * @type {string}
     * @memberof PluginInterfaceType
     */
    Version: string;
}

/**
 * PluginMount plugin mount
 * @export
 * @interface PluginMount
 */
export interface PluginMount {
    /**
     * description
     * @type {string}
     * @memberof PluginMount
     */
    Description: string;
    /**
     * destination
     * @type {string}
     * @memberof PluginMount
     */
    Destination: string;
    /**
     * name
     * @type {string}
     * @memberof PluginMount
     */
    Name: string;
    /**
     * options
     * @type {Array<string>}
     * @memberof PluginMount
     */
    Options: Array<string>;
    /**
     * settable
     * @type {Array<string>}
     * @memberof PluginMount
     */
    Settable: Array<string>;
    /**
     * source
     * @type {string}
     * @memberof PluginMount
     */
    Source: string;
    /**
     * type
     * @type {string}
     * @memberof PluginMount
     */
    Type: string;
}

/**
 * 
 * @export
 * @interface PluginSettings
 */
export interface PluginSettings {
    /**
     * args
     * @type {Array<string>}
     * @memberof PluginSettings
     */
    Args: Array<string>;
    /**
     * devices
     * @type {Array<PluginDevice>}
     * @memberof PluginSettings
     */
    Devices: Array<PluginDevice>;
    /**
     * env
     * @type {Array<string>}
     * @memberof PluginSettings
     */
    Env: Array<string>;
    /**
     * mounts
     * @type {Array<PluginMount>}
     * @memberof PluginSettings
     */
    Mounts: Array<PluginMount>;
}

/**
 * Port An open port on a container
 * @export
 * @interface Port
 */
export interface Port {
    /**
     * IP
     * @type {string}
     * @memberof Port
     */
    IP?: string;
    /**
     * Port on the container
     * @type {number}
     * @memberof Port
     */
    PrivatePort: number;
    /**
     * Port exposed on the host
     * @type {number}
     * @memberof Port
     */
    PublicPort?: number;
    /**
     * type
     * @type {string}
     * @memberof Port
     */
    Type: string;
}

/**
 * Protocol used to transport messages
 * @export
 * @interface Protocol
 */
export interface Protocol {
}

/**
 * 
 * @export
 * @interface ServiceState
 */
export interface ServiceState {
}

/**
 * ServiceType describes the service type (analyzer or agent)
 * @export
 * @interface ServiceType
 */
export interface ServiceType {
}

/**
 * ServiceUpdateResponse service update response
 * @export
 * @interface ServiceUpdateResponse
 */
export interface ServiceUpdateResponse {
    /**
     * Optional warning messages
     * @type {Array<string>}
     * @memberof ServiceUpdateResponse
     */
    Warnings?: Array<string>;
}

/**
 * TopologyParams topology query parameters 
 * @export
 * @interface TopologyParams
 */
export interface TopologyParams {
    /**
     * 
     * @type {string}
     * @memberof TopologyParams
     */
    GremlinQuery?: string;
}

/**
 * Volume volume
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     * Name of the volume driver used by the volume.
     * @type {string}
     * @memberof Volume
     */
    Driver: string;
    /**
     * User-defined key/value metadata.
     * @type {{ [key: string]: string; }}
     * @memberof Volume
     */
    Labels: { [key: string]: string; };
    /**
     * Mount path of the volume on the host.
     * @type {string}
     * @memberof Volume
     */
    Mountpoint: string;
    /**
     * Name of the volume.
     * @type {string}
     * @memberof Volume
     */
    Name: string;
    /**
     * The driver specific options used when creating the volume.
     * @type {{ [key: string]: string; }}
     * @memberof Volume
     */
    Options: { [key: string]: string; };
    /**
     * The level at which the volume exists. Either `global` for cluster-wide, or `local` for machine level.
     * @type {string}
     * @memberof Volume
     */
    Scope: string;
    /**
     * Low-level details about the volume, provided by the volume driver. Details are returned as a map with key/value pairs: `{\"key\":\"value\",\"key2\":\"value2\"}`.  The `Status` field is optional, and is omitted if the volume driver does not support this feature.
     * @type {{ [key: string]: any; }}
     * @memberof Volume
     */
    Status?: { [key: string]: any; };
    /**
     * 
     * @type {VolumeUsageData}
     * @memberof Volume
     */
    UsageData?: VolumeUsageData;
}

/**
 * VolumeUsageData volume usage data
 * @export
 * @interface VolumeUsageData
 */
export interface VolumeUsageData {
    /**
     * The number of containers referencing this volume.
     * @type {number}
     * @memberof VolumeUsageData
     */
    RefCount: number;
    /**
     * The disk space used by the volume (local driver only)
     * @type {number}
     * @memberof VolumeUsageData
     */
    Size: number;
}

/**
 * VolumesCreateBody volumes create body
 * @export
 * @interface VolumesCreateBody
 */
export interface VolumesCreateBody {
    /**
     * Name of the volume driver to use.
     * @type {string}
     * @memberof VolumesCreateBody
     */
    Driver: string;
    /**
     * A mapping of driver options and values. These options are passed directly to the driver and are driver specific.
     * @type {{ [key: string]: string; }}
     * @memberof VolumesCreateBody
     */
    DriverOpts: { [key: string]: string; };
    /**
     * User-defined key/value metadata.
     * @type {{ [key: string]: string; }}
     * @memberof VolumesCreateBody
     */
    Labels: { [key: string]: string; };
    /**
     * The new volume's name. If not specified, Docker generates a name.
     * @type {string}
     * @memberof VolumesCreateBody
     */
    Name: string;
}

/**
 * VolumesListOKBody volumes list o k body
 * @export
 * @interface VolumesListOKBody
 */
export interface VolumesListOKBody {
    /**
     * List of volumes
     * @type {Array<Volume>}
     * @memberof VolumesListOKBody
     */
    Volumes: Array<Volume>;
    /**
     * Warnings that occurred when fetching the list of volumes
     * @type {Array<string>}
     * @memberof VolumesListOKBody
     */
    Warnings: Array<string>;
}

/**
 * Workflow allows to automate actions using JavaScript.  
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * Workflow abstract
     * @type {string}
     * @memberof Workflow
     */
    _Abstract?: string;
    /**
     * Workflow description
     * @type {string}
     * @memberof Workflow
     */
    Description?: string;
    /**
     * Workflow name
     * @type {string}
     * @memberof Workflow
     */
    Name?: string;
    /**
     * Workflow parameters
     * @type {Array<WorkflowParam>}
     * @memberof Workflow
     */
    Parameters?: Array<WorkflowParam>;
    /**
     * 
     * @type {string}
     * @memberof Workflow
     */
    Source?: string;
    /**
     * Workflow title
     * @type {string}
     * @memberof Workflow
     */
    Title?: string;
}

/**
 * WorkflowCall describes workflow call
 * @export
 * @interface WorkflowCall
 */
export interface WorkflowCall {
    /**
     * 
     * @type {Array<any>}
     * @memberof WorkflowCall
     */
    Params?: Array<any>;
}

/**
 * WorkflowChoice describes one value within a choice 
 * @export
 * @interface WorkflowChoice
 */
export interface WorkflowChoice {
    /**
     * 
     * @type {string}
     * @memberof WorkflowChoice
     */
    Description?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowChoice
     */
    Value?: string;
}

/**
 * WorkflowParam describes a workflow parameter 
 * @export
 * @interface WorkflowParam
 */
export interface WorkflowParam {
    /**
     * 
     * @type {any}
     * @memberof WorkflowParam
     */
    _Default?: any;
    /**
     * 
     * @type {string}
     * @memberof WorkflowParam
     */
    Description?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowParam
     */
    Name?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkflowParam
     */
    Type?: string;
    /**
     * 
     * @type {Array<WorkflowChoice>}
     * @memberof WorkflowParam
     */
    Values?: Array<WorkflowChoice>;
}

/**
 * Workflows
 * @export
 * @interface Workflows
 */
export interface Workflows {
    [key: string]: Workflow;

}


/**
 * APIInfoApi - fetch parameter creator
 * @export
 */
export const APIInfoApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get API version
         * @summary Get API info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApi(options: any = {}): FetchArgs {
            const localVarPath = `/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * APIInfoApi - functional programming interface
 * @export
 */
export const APIInfoApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get API version
         * @summary Get API info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApi(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Info> {
            const localVarFetchArgs = APIInfoApiFetchParamCreator(configuration).getApi(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * APIInfoApi - factory interface
 * @export
 */
export const APIInfoApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get API version
         * @summary Get API info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getApi(options?: any) {
            return APIInfoApiFp(configuration).getApi(options)(fetch, basePath);
        },
    };
};

/**
 * APIInfoApi - object-oriented interface
 * @export
 * @class APIInfoApi
 * @extends {BaseAPI}
 */
export class APIInfoApi extends BaseAPI {
    /**
     * Get API version
     * @summary Get API info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof APIInfoApi
     */
    public getApi(options?: any) {
        return APIInfoApiFp(this.configuration).getApi(options)(this.fetch, this.basePath);
    }

}

/**
 * AlertsApi - fetch parameter creator
 * @export
 */
export const AlertsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an alert
         * @summary Create alert
         * @param {Alert} alert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(alert: Alert, options: any = {}): FetchArgs {
            // verify required parameter 'alert' is not null or undefined
            if (alert === null || alert === undefined) {
                throw new RequiredError('alert', 'Required parameter alert was null or undefined when calling createAlert.');
            }
            const localVarPath = `/alert`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Alert" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(alert || {}) : (alert || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an alert
         * @summary Delete alert
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteAlert.');
            }
            const localVarPath = `/alert/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an alert
         * @summary Get alert
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlert(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getAlert.');
            }
            const localVarPath = `/alert/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List alerts
         * @summary List alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(options: any = {}): FetchArgs {
            const localVarPath = `/alert`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AlertsApi - functional programming interface
 * @export
 */
export const AlertsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create an alert
         * @summary Create alert
         * @param {Alert} alert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(alert: Alert, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alert> {
            const localVarFetchArgs = AlertsApiFetchParamCreator(configuration).createAlert(alert, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an alert
         * @summary Delete alert
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AlertsApiFetchParamCreator(configuration).deleteAlert(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an alert
         * @summary Get alert
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlert(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alert> {
            const localVarFetchArgs = AlertsApiFetchParamCreator(configuration).getAlert(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List alerts
         * @summary List alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Alerts> {
            const localVarFetchArgs = AlertsApiFetchParamCreator(configuration).listAlerts(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AlertsApi - factory interface
 * @export
 */
export const AlertsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create an alert
         * @summary Create alert
         * @param {Alert} alert 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAlert(alert: Alert, options?: any) {
            return AlertsApiFp(configuration).createAlert(alert, options)(fetch, basePath);
        },
        /**
         * Delete an alert
         * @summary Delete alert
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAlert(id: string, options?: any) {
            return AlertsApiFp(configuration).deleteAlert(id, options)(fetch, basePath);
        },
        /**
         * Get an alert
         * @summary Get alert
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAlert(id: string, options?: any) {
            return AlertsApiFp(configuration).getAlert(id, options)(fetch, basePath);
        },
        /**
         * List alerts
         * @summary List alerts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAlerts(options?: any) {
            return AlertsApiFp(configuration).listAlerts(options)(fetch, basePath);
        },
    };
};

/**
 * AlertsApi - object-oriented interface
 * @export
 * @class AlertsApi
 * @extends {BaseAPI}
 */
export class AlertsApi extends BaseAPI {
    /**
     * Create an alert
     * @summary Create alert
     * @param {Alert} alert 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public createAlert(alert: Alert, options?: any) {
        return AlertsApiFp(this.configuration).createAlert(alert, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an alert
     * @summary Delete alert
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public deleteAlert(id: string, options?: any) {
        return AlertsApiFp(this.configuration).deleteAlert(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get an alert
     * @summary Get alert
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public getAlert(id: string, options?: any) {
        return AlertsApiFp(this.configuration).getAlert(id, options)(this.fetch, this.basePath);
    }

    /**
     * List alerts
     * @summary List alerts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertsApi
     */
    public listAlerts(options?: any) {
        return AlertsApiFp(this.configuration).listAlerts(options)(this.fetch, this.basePath);
    }

}

/**
 * CapturesApi - fetch parameter creator
 * @export
 */
export const CapturesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a capture
         * @summary Create capture
         * @param {Capture} capture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCapture(capture: Capture, options: any = {}): FetchArgs {
            // verify required parameter 'capture' is not null or undefined
            if (capture === null || capture === undefined) {
                throw new RequiredError('capture', 'Required parameter capture was null or undefined when calling createCapture.');
            }
            const localVarPath = `/capture`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Capture" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(capture || {}) : (capture || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a capture
         * @summary Delete capture
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCapture(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteCapture.');
            }
            const localVarPath = `/capture/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a capture
         * @summary Get capture
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCapture(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getCapture.');
            }
            const localVarPath = `/capture/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List captures
         * @summary List captures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCaptures(options: any = {}): FetchArgs {
            const localVarPath = `/capture`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CapturesApi - functional programming interface
 * @export
 */
export const CapturesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create a capture
         * @summary Create capture
         * @param {Capture} capture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCapture(capture: Capture, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Capture> {
            const localVarFetchArgs = CapturesApiFetchParamCreator(configuration).createCapture(capture, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a capture
         * @summary Delete capture
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCapture(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CapturesApiFetchParamCreator(configuration).deleteCapture(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a capture
         * @summary Get capture
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCapture(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Capture> {
            const localVarFetchArgs = CapturesApiFetchParamCreator(configuration).getCapture(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List captures
         * @summary List captures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCaptures(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Captures> {
            const localVarFetchArgs = CapturesApiFetchParamCreator(configuration).listCaptures(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CapturesApi - factory interface
 * @export
 */
export const CapturesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a capture
         * @summary Create capture
         * @param {Capture} capture 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCapture(capture: Capture, options?: any) {
            return CapturesApiFp(configuration).createCapture(capture, options)(fetch, basePath);
        },
        /**
         * Delete a capture
         * @summary Delete capture
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCapture(id: string, options?: any) {
            return CapturesApiFp(configuration).deleteCapture(id, options)(fetch, basePath);
        },
        /**
         * Get a capture
         * @summary Get capture
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCapture(id: string, options?: any) {
            return CapturesApiFp(configuration).getCapture(id, options)(fetch, basePath);
        },
        /**
         * List captures
         * @summary List captures
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listCaptures(options?: any) {
            return CapturesApiFp(configuration).listCaptures(options)(fetch, basePath);
        },
    };
};

/**
 * CapturesApi - object-oriented interface
 * @export
 * @class CapturesApi
 * @extends {BaseAPI}
 */
export class CapturesApi extends BaseAPI {
    /**
     * Create a capture
     * @summary Create capture
     * @param {Capture} capture 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public createCapture(capture: Capture, options?: any) {
        return CapturesApiFp(this.configuration).createCapture(capture, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a capture
     * @summary Delete capture
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public deleteCapture(id: string, options?: any) {
        return CapturesApiFp(this.configuration).deleteCapture(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a capture
     * @summary Get capture
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public getCapture(id: string, options?: any) {
        return CapturesApiFp(this.configuration).getCapture(id, options)(this.fetch, this.basePath);
    }

    /**
     * List captures
     * @summary List captures
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CapturesApi
     */
    public listCaptures(options?: any) {
        return CapturesApiFp(this.configuration).listCaptures(options)(this.fetch, this.basePath);
    }

}

/**
 * ConfigApi - fetch parameter creator
 * @export
 */
export const ConfigApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get configuration value
         * @summary Get configuration
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key', 'Required parameter key was null or undefined when calling getConfig.');
            }
            const localVarPath = `/config/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConfigApi - functional programming interface
 * @export
 */
export const ConfigApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get configuration value
         * @summary Get configuration
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnyValue> {
            const localVarFetchArgs = ConfigApiFetchParamCreator(configuration).getConfig(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConfigApi - factory interface
 * @export
 */
export const ConfigApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get configuration value
         * @summary Get configuration
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfig(key: string, options?: any) {
            return ConfigApiFp(configuration).getConfig(key, options)(fetch, basePath);
        },
    };
};

/**
 * ConfigApi - object-oriented interface
 * @export
 * @class ConfigApi
 * @extends {BaseAPI}
 */
export class ConfigApi extends BaseAPI {
    /**
     * Get configuration value
     * @summary Get configuration
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConfigApi
     */
    public getConfig(key: string, options?: any) {
        return ConfigApiFp(this.configuration).getConfig(key, options)(this.fetch, this.basePath);
    }

}

/**
 * EdgeRulesApi - fetch parameter creator
 * @export
 */
export const EdgeRulesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an edge rule
         * @summary Create edge rule
         * @param {EdgeRule} edge_rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdgeRule(edge_rule: EdgeRule, options: any = {}): FetchArgs {
            // verify required parameter 'edge_rule' is not null or undefined
            if (edge_rule === null || edge_rule === undefined) {
                throw new RequiredError('edge_rule', 'Required parameter edge_rule was null or undefined when calling createEdgeRule.');
            }
            const localVarPath = `/edgerule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EdgeRule" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(edge_rule || {}) : (edge_rule || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an edge rule
         * @summary Delete edge rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEdgeRule(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteEdgeRule.');
            }
            const localVarPath = `/edgerule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an edge rule
         * @summary Get edge rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEdgeRule(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getEdgeRule.');
            }
            const localVarPath = `/edgerule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List edge rules
         * @summary List edge rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEdgeRules(options: any = {}): FetchArgs {
            const localVarPath = `/edgerule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EdgeRulesApi - functional programming interface
 * @export
 */
export const EdgeRulesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create an edge rule
         * @summary Create edge rule
         * @param {EdgeRule} edge_rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdgeRule(edge_rule: EdgeRule, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EdgeRule> {
            const localVarFetchArgs = EdgeRulesApiFetchParamCreator(configuration).createEdgeRule(edge_rule, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an edge rule
         * @summary Delete edge rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEdgeRule(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EdgeRulesApiFetchParamCreator(configuration).deleteEdgeRule(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an edge rule
         * @summary Get edge rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEdgeRule(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EdgeRule> {
            const localVarFetchArgs = EdgeRulesApiFetchParamCreator(configuration).getEdgeRule(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List edge rules
         * @summary List edge rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEdgeRules(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<EdgeRules> {
            const localVarFetchArgs = EdgeRulesApiFetchParamCreator(configuration).listEdgeRules(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EdgeRulesApi - factory interface
 * @export
 */
export const EdgeRulesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create an edge rule
         * @summary Create edge rule
         * @param {EdgeRule} edge_rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEdgeRule(edge_rule: EdgeRule, options?: any) {
            return EdgeRulesApiFp(configuration).createEdgeRule(edge_rule, options)(fetch, basePath);
        },
        /**
         * Delete an edge rule
         * @summary Delete edge rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEdgeRule(id: string, options?: any) {
            return EdgeRulesApiFp(configuration).deleteEdgeRule(id, options)(fetch, basePath);
        },
        /**
         * Get an edge rule
         * @summary Get edge rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEdgeRule(id: string, options?: any) {
            return EdgeRulesApiFp(configuration).getEdgeRule(id, options)(fetch, basePath);
        },
        /**
         * List edge rules
         * @summary List edge rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEdgeRules(options?: any) {
            return EdgeRulesApiFp(configuration).listEdgeRules(options)(fetch, basePath);
        },
    };
};

/**
 * EdgeRulesApi - object-oriented interface
 * @export
 * @class EdgeRulesApi
 * @extends {BaseAPI}
 */
export class EdgeRulesApi extends BaseAPI {
    /**
     * Create an edge rule
     * @summary Create edge rule
     * @param {EdgeRule} edge_rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeRulesApi
     */
    public createEdgeRule(edge_rule: EdgeRule, options?: any) {
        return EdgeRulesApiFp(this.configuration).createEdgeRule(edge_rule, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an edge rule
     * @summary Delete edge rule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeRulesApi
     */
    public deleteEdgeRule(id: string, options?: any) {
        return EdgeRulesApiFp(this.configuration).deleteEdgeRule(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get an edge rule
     * @summary Get edge rule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeRulesApi
     */
    public getEdgeRule(id: string, options?: any) {
        return EdgeRulesApiFp(this.configuration).getEdgeRule(id, options)(this.fetch, this.basePath);
    }

    /**
     * List edge rules
     * @summary List edge rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EdgeRulesApi
     */
    public listEdgeRules(options?: any) {
        return EdgeRulesApiFp(this.configuration).listEdgeRules(options)(this.fetch, this.basePath);
    }

}

/**
 * InjectionsApi - fetch parameter creator
 * @export
 */
export const InjectionsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an injection
         * @summary Create injection
         * @param {PacketInjection} injection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPacketInjection(injection: PacketInjection, options: any = {}): FetchArgs {
            // verify required parameter 'injection' is not null or undefined
            if (injection === null || injection === undefined) {
                throw new RequiredError('injection', 'Required parameter injection was null or undefined when calling createPacketInjection.');
            }
            const localVarPath = `/injectpacket`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PacketInjection" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(injection || {}) : (injection || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an injection
         * @summary Delete injection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePacketInjection(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deletePacketInjection.');
            }
            const localVarPath = `/injectpacket/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an injection
         * @summary Get injection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPacketInjection(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getPacketInjection.');
            }
            const localVarPath = `/injectpacket/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List injections
         * @summary List injections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPacketInjections(options: any = {}): FetchArgs {
            const localVarPath = `/injectpacket`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InjectionsApi - functional programming interface
 * @export
 */
export const InjectionsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create an injection
         * @summary Create injection
         * @param {PacketInjection} injection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPacketInjection(injection: PacketInjection, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PacketInjection> {
            const localVarFetchArgs = InjectionsApiFetchParamCreator(configuration).createPacketInjection(injection, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete an injection
         * @summary Delete injection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePacketInjection(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InjectionsApiFetchParamCreator(configuration).deletePacketInjection(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get an injection
         * @summary Get injection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPacketInjection(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PacketInjection> {
            const localVarFetchArgs = InjectionsApiFetchParamCreator(configuration).getPacketInjection(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List injections
         * @summary List injections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPacketInjections(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<PacketInjections> {
            const localVarFetchArgs = InjectionsApiFetchParamCreator(configuration).listPacketInjections(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InjectionsApi - factory interface
 * @export
 */
export const InjectionsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create an injection
         * @summary Create injection
         * @param {PacketInjection} injection 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPacketInjection(injection: PacketInjection, options?: any) {
            return InjectionsApiFp(configuration).createPacketInjection(injection, options)(fetch, basePath);
        },
        /**
         * Delete an injection
         * @summary Delete injection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePacketInjection(id: string, options?: any) {
            return InjectionsApiFp(configuration).deletePacketInjection(id, options)(fetch, basePath);
        },
        /**
         * Get an injection
         * @summary Get injection
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPacketInjection(id: string, options?: any) {
            return InjectionsApiFp(configuration).getPacketInjection(id, options)(fetch, basePath);
        },
        /**
         * List injections
         * @summary List injections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPacketInjections(options?: any) {
            return InjectionsApiFp(configuration).listPacketInjections(options)(fetch, basePath);
        },
    };
};

/**
 * InjectionsApi - object-oriented interface
 * @export
 * @class InjectionsApi
 * @extends {BaseAPI}
 */
export class InjectionsApi extends BaseAPI {
    /**
     * Create an injection
     * @summary Create injection
     * @param {PacketInjection} injection 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InjectionsApi
     */
    public createPacketInjection(injection: PacketInjection, options?: any) {
        return InjectionsApiFp(this.configuration).createPacketInjection(injection, options)(this.fetch, this.basePath);
    }

    /**
     * Delete an injection
     * @summary Delete injection
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InjectionsApi
     */
    public deletePacketInjection(id: string, options?: any) {
        return InjectionsApiFp(this.configuration).deletePacketInjection(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get an injection
     * @summary Get injection
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InjectionsApi
     */
    public getPacketInjection(id: string, options?: any) {
        return InjectionsApiFp(this.configuration).getPacketInjection(id, options)(this.fetch, this.basePath);
    }

    /**
     * List injections
     * @summary List injections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InjectionsApi
     */
    public listPacketInjections(options?: any) {
        return InjectionsApiFp(this.configuration).listPacketInjections(options)(this.fetch, this.basePath);
    }

}

/**
 * LoginApi - fetch parameter creator
 * @export
 */
export const LoginApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Login
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(username: string, password: string, options: any = {}): FetchArgs {
            // verify required parameter 'username' is not null or undefined
            if (username === null || username === undefined) {
                throw new RequiredError('username', 'Required parameter username was null or undefined when calling login.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password', 'Required parameter password was null or undefined when calling login.');
            }
            const localVarPath = `/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (username !== undefined) {
                localVarFormParams.set('username', username as any);
            }

            if (password !== undefined) {
                localVarFormParams.set('password', password as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LoginApi - functional programming interface
 * @export
 */
export const LoginApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Login
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(username: string, password: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LoginApiFetchParamCreator(configuration).login(username, password, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LoginApi - factory interface
 * @export
 */
export const LoginApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Login
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(username: string, password: string, options?: any) {
            return LoginApiFp(configuration).login(username, password, options)(fetch, basePath);
        },
    };
};

/**
 * LoginApi - object-oriented interface
 * @export
 * @class LoginApi
 * @extends {BaseAPI}
 */
export class LoginApi extends BaseAPI {
    /**
     * Login
     * @summary Login
     * @param {string} username 
     * @param {string} password 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LoginApi
     */
    public login(username: string, password: string, options?: any) {
        return LoginApiFp(this.configuration).login(username, password, options)(this.fetch, this.basePath);
    }

}

/**
 * NodeRulesApi - fetch parameter creator
 * @export
 */
export const NodeRulesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a node rule
         * @summary Create node rule
         * @param {NodeRule} node_rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNodeRule(node_rule: NodeRule, options: any = {}): FetchArgs {
            // verify required parameter 'node_rule' is not null or undefined
            if (node_rule === null || node_rule === undefined) {
                throw new RequiredError('node_rule', 'Required parameter node_rule was null or undefined when calling createNodeRule.');
            }
            const localVarPath = `/noderule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"NodeRule" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(node_rule || {}) : (node_rule || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a node rule
         * @summary Delete node rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNodeRule(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteNodeRule.');
            }
            const localVarPath = `/noderule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a node rule
         * @summary Get node rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeRule(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getNodeRule.');
            }
            const localVarPath = `/noderule/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List node rules
         * @summary List node rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeRules(options: any = {}): FetchArgs {
            const localVarPath = `/noderule`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodeRulesApi - functional programming interface
 * @export
 */
export const NodeRulesApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Create a node rule
         * @summary Create node rule
         * @param {NodeRule} node_rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNodeRule(node_rule: NodeRule, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NodeRule> {
            const localVarFetchArgs = NodeRulesApiFetchParamCreator(configuration).createNodeRule(node_rule, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a node rule
         * @summary Delete node rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNodeRule(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = NodeRulesApiFetchParamCreator(configuration).deleteNodeRule(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a node rule
         * @summary Get node rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeRule(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NodeRule> {
            const localVarFetchArgs = NodeRulesApiFetchParamCreator(configuration).getNodeRule(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List node rules
         * @summary List node rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeRules(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<NodeRules> {
            const localVarFetchArgs = NodeRulesApiFetchParamCreator(configuration).listNodeRules(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * NodeRulesApi - factory interface
 * @export
 */
export const NodeRulesApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Create a node rule
         * @summary Create node rule
         * @param {NodeRule} node_rule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNodeRule(node_rule: NodeRule, options?: any) {
            return NodeRulesApiFp(configuration).createNodeRule(node_rule, options)(fetch, basePath);
        },
        /**
         * Delete a node rule
         * @summary Delete node rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNodeRule(id: string, options?: any) {
            return NodeRulesApiFp(configuration).deleteNodeRule(id, options)(fetch, basePath);
        },
        /**
         * Get a node rule
         * @summary Get node rule
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeRule(id: string, options?: any) {
            return NodeRulesApiFp(configuration).getNodeRule(id, options)(fetch, basePath);
        },
        /**
         * List node rules
         * @summary List node rules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeRules(options?: any) {
            return NodeRulesApiFp(configuration).listNodeRules(options)(fetch, basePath);
        },
    };
};

/**
 * NodeRulesApi - object-oriented interface
 * @export
 * @class NodeRulesApi
 * @extends {BaseAPI}
 */
export class NodeRulesApi extends BaseAPI {
    /**
     * Create a node rule
     * @summary Create node rule
     * @param {NodeRule} node_rule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRulesApi
     */
    public createNodeRule(node_rule: NodeRule, options?: any) {
        return NodeRulesApiFp(this.configuration).createNodeRule(node_rule, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a node rule
     * @summary Delete node rule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRulesApi
     */
    public deleteNodeRule(id: string, options?: any) {
        return NodeRulesApiFp(this.configuration).deleteNodeRule(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a node rule
     * @summary Get node rule
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRulesApi
     */
    public getNodeRule(id: string, options?: any) {
        return NodeRulesApiFp(this.configuration).getNodeRule(id, options)(this.fetch, this.basePath);
    }

    /**
     * List node rules
     * @summary List node rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRulesApi
     */
    public listNodeRules(options?: any) {
        return NodeRulesApiFp(this.configuration).listNodeRules(options)(this.fetch, this.basePath);
    }

}

/**
 * PCAPApi - fetch parameter creator
 * @export
 */
export const PCAPApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Inject PCAP
         * @summary Inject PCAP
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        injectPCAP(status: string, options: any = {}): FetchArgs {
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new RequiredError('status', 'Required parameter status was null or undefined when calling injectPCAP.');
            }
            const localVarPath = `/pcap`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"string" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(status || {}) : (status || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PCAPApi - functional programming interface
 * @export
 */
export const PCAPApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Inject PCAP
         * @summary Inject PCAP
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        injectPCAP(status: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PCAPApiFetchParamCreator(configuration).injectPCAP(status, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PCAPApi - factory interface
 * @export
 */
export const PCAPApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Inject PCAP
         * @summary Inject PCAP
         * @param {string} status 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        injectPCAP(status: string, options?: any) {
            return PCAPApiFp(configuration).injectPCAP(status, options)(fetch, basePath);
        },
    };
};

/**
 * PCAPApi - object-oriented interface
 * @export
 * @class PCAPApi
 * @extends {BaseAPI}
 */
export class PCAPApi extends BaseAPI {
    /**
     * Inject PCAP
     * @summary Inject PCAP
     * @param {string} status 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PCAPApi
     */
    public injectPCAP(status: string, options?: any) {
        return PCAPApiFp(this.configuration).injectPCAP(status, options)(this.fetch, this.basePath);
    }

}

/**
 * StatusApi - fetch parameter creator
 * @export
 */
export const StatusApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get status
         * @summary Get status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options: any = {}): FetchArgs {
            const localVarPath = `/status`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get status
         * @summary Get status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StatusApiFetchParamCreator(configuration).getStatus(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get status
         * @summary Get status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any) {
            return StatusApiFp(configuration).getStatus(options)(fetch, basePath);
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * Get status
     * @summary Get status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatus(options?: any) {
        return StatusApiFp(this.configuration).getStatus(options)(this.fetch, this.basePath);
    }

}

/**
 * TopologyApi - fetch parameter creator
 * @export
 */
export const TopologyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get topology
         * @summary Get topology
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopology(options: any = {}): FetchArgs {
            const localVarPath = `/topology`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search topology
         * @summary Search topology
         * @param {TopologyParams} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTopology(params: TopologyParams, options: any = {}): FetchArgs {
            // verify required parameter 'params' is not null or undefined
            if (params === null || params === undefined) {
                throw new RequiredError('params', 'Required parameter params was null or undefined when calling searchTopology.');
            }
            const localVarPath = `/topology`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TopologyParams" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(params || {}) : (params || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TopologyApi - functional programming interface
 * @export
 */
export const TopologyApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Get topology
         * @summary Get topology
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopology(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = TopologyApiFetchParamCreator(configuration).getTopology(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Search topology
         * @summary Search topology
         * @param {TopologyParams} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTopology(params: TopologyParams, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnyValue> {
            const localVarFetchArgs = TopologyApiFetchParamCreator(configuration).searchTopology(params, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TopologyApi - factory interface
 * @export
 */
export const TopologyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get topology
         * @summary Get topology
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopology(options?: any) {
            return TopologyApiFp(configuration).getTopology(options)(fetch, basePath);
        },
        /**
         * Search topology
         * @summary Search topology
         * @param {TopologyParams} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTopology(params: TopologyParams, options?: any) {
            return TopologyApiFp(configuration).searchTopology(params, options)(fetch, basePath);
        },
    };
};

/**
 * TopologyApi - object-oriented interface
 * @export
 * @class TopologyApi
 * @extends {BaseAPI}
 */
export class TopologyApi extends BaseAPI {
    /**
     * Get topology
     * @summary Get topology
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopologyApi
     */
    public getTopology(options?: any) {
        return TopologyApiFp(this.configuration).getTopology(options)(this.fetch, this.basePath);
    }

    /**
     * Search topology
     * @summary Search topology
     * @param {TopologyParams} params 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TopologyApi
     */
    public searchTopology(params: TopologyParams, options?: any) {
        return TopologyApiFp(this.configuration).searchTopology(params, options)(this.fetch, this.basePath);
    }

}

/**
 * WorkflowsApi - fetch parameter creator
 * @export
 */
export const WorkflowsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Call workflow
         * @summary Call workflow
         * @param {string} id 
         * @param {WorkflowCall} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callWorkflow(id: string, params: WorkflowCall, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling callWorkflow.');
            }
            // verify required parameter 'params' is not null or undefined
            if (params === null || params === undefined) {
                throw new RequiredError('params', 'Required parameter params was null or undefined when calling callWorkflow.');
            }
            const localVarPath = `/workflow/{id}/call`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"WorkflowCall" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(params || {}) : (params || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a workflow
         * @summary Create workflow
         * @param {Workflow} workflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(workflow: Workflow, options: any = {}): FetchArgs {
            // verify required parameter 'workflow' is not null or undefined
            if (workflow === null || workflow === undefined) {
                throw new RequiredError('workflow', 'Required parameter workflow was null or undefined when calling createWorkflow.');
            }
            const localVarPath = `/workflow`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Workflow" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body = needsSerialization ? JSON.stringify(workflow || {}) : (workflow || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a workflow
         * @summary Delete workflow
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling deleteWorkflow.');
            }
            const localVarPath = `/workflow/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a workflow
         * @summary Get workflow
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id', 'Required parameter id was null or undefined when calling getWorkflow.');
            }
            const localVarPath = `/workflow/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List workflows
         * @summary List workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(options: any = {}): FetchArgs {
            const localVarPath = `/workflow`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WorkflowsApi - functional programming interface
 * @export
 */
export const WorkflowsApiFp = function (configuration?: Configuration) {
    return {
        /**
         * Call workflow
         * @summary Call workflow
         * @param {string} id 
         * @param {WorkflowCall} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callWorkflow(id: string, params: WorkflowCall, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AnyValue> {
            const localVarFetchArgs = WorkflowsApiFetchParamCreator(configuration).callWorkflow(id, params, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a workflow
         * @summary Create workflow
         * @param {Workflow} workflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(workflow: Workflow, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Workflow> {
            const localVarFetchArgs = WorkflowsApiFetchParamCreator(configuration).createWorkflow(workflow, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delete a workflow
         * @summary Delete workflow
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = WorkflowsApiFetchParamCreator(configuration).deleteWorkflow(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get a workflow
         * @summary Get workflow
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Workflow> {
            const localVarFetchArgs = WorkflowsApiFetchParamCreator(configuration).getWorkflow(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * List workflows
         * @summary List workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Workflows> {
            const localVarFetchArgs = WorkflowsApiFetchParamCreator(configuration).listWorkflows(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * WorkflowsApi - factory interface
 * @export
 */
export const WorkflowsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Call workflow
         * @summary Call workflow
         * @param {string} id 
         * @param {WorkflowCall} params 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callWorkflow(id: string, params: WorkflowCall, options?: any) {
            return WorkflowsApiFp(configuration).callWorkflow(id, params, options)(fetch, basePath);
        },
        /**
         * Create a workflow
         * @summary Create workflow
         * @param {Workflow} workflow 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(workflow: Workflow, options?: any) {
            return WorkflowsApiFp(configuration).createWorkflow(workflow, options)(fetch, basePath);
        },
        /**
         * Delete a workflow
         * @summary Delete workflow
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(id: string, options?: any) {
            return WorkflowsApiFp(configuration).deleteWorkflow(id, options)(fetch, basePath);
        },
        /**
         * Get a workflow
         * @summary Get workflow
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(id: string, options?: any) {
            return WorkflowsApiFp(configuration).getWorkflow(id, options)(fetch, basePath);
        },
        /**
         * List workflows
         * @summary List workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listWorkflows(options?: any) {
            return WorkflowsApiFp(configuration).listWorkflows(options)(fetch, basePath);
        },
    };
};

/**
 * WorkflowsApi - object-oriented interface
 * @export
 * @class WorkflowsApi
 * @extends {BaseAPI}
 */
export class WorkflowsApi extends BaseAPI {
    /**
     * Call workflow
     * @summary Call workflow
     * @param {string} id 
     * @param {WorkflowCall} params 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public callWorkflow(id: string, params: WorkflowCall, options?: any) {
        return WorkflowsApiFp(this.configuration).callWorkflow(id, params, options)(this.fetch, this.basePath);
    }

    /**
     * Create a workflow
     * @summary Create workflow
     * @param {Workflow} workflow 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public createWorkflow(workflow: Workflow, options?: any) {
        return WorkflowsApiFp(this.configuration).createWorkflow(workflow, options)(this.fetch, this.basePath);
    }

    /**
     * Delete a workflow
     * @summary Delete workflow
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public deleteWorkflow(id: string, options?: any) {
        return WorkflowsApiFp(this.configuration).deleteWorkflow(id, options)(this.fetch, this.basePath);
    }

    /**
     * Get a workflow
     * @summary Get workflow
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public getWorkflow(id: string, options?: any) {
        return WorkflowsApiFp(this.configuration).getWorkflow(id, options)(this.fetch, this.basePath);
    }

    /**
     * List workflows
     * @summary List workflows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WorkflowsApi
     */
    public listWorkflows(options?: any) {
        return WorkflowsApiFp(this.configuration).listWorkflows(options)(this.fetch, this.basePath);
    }

}

